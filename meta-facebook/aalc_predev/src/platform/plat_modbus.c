/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "plat_modbus.h"
#include "plat_sensor_table.h"
#include <sys/util.h>
#include <drivers/gpio.h>
#include <modbus/modbus.h>
#include <logging/log.h>
#include "sensor.h"
#include "modbus_server.h"
#include "fru.h"
#include "eeprom.h"
#include "plat_fru.h"
#include <time.h>
#include "adm1272.h"

LOG_MODULE_REGISTER(plat_modbus);

struct k_thread modbus_server_thread;
K_KERNEL_STACK_MEMBER(modbus_server_thread_stack, MODBUS_SERVER_THREAD_SIZE);

static char server_iface_name[] = "MODBUS0";
//{DT_PROP(DT_INST(1, zephyr_modbus_serial), label)};
static uint16_t regs_wr[16];
static uint16_t regs_rd[16];
static uint8_t cb_num;
static uint16_t cb_addr[2];

modbus_sensor_cfg plat_modbus_sensors[] = {
	/* sensor number,  modbus data addr  */
	{ SENSOR_NUM_BPB_RPU_COOLANT_FLOW_RATE_LPM, MODBUS_BPB_RPU_COOLANT_FLOW_RATE_LPM_ADDR },
	{ SENSOR_NUM_BPB_RPU_COOLANT_OUTLET_TEMP_C, MODBUS_BPB_RPU_COOLANT_OUTLET_TEMP_ADDR },
	{ SENSOR_NUM_BPB_RPU_COOLANT_INLET_TEMP_C, MODBUS_BPB_RPU_COOLANT_INLET_TEMP_ADDR },
	{ SENSOR_NUM_BPB_RPU_COOLANT_OUTLET_P_KPA, MODBUS_BPB_RPU_COOLANT_OUTLET_P_KPA_ADDR },
	{ SENSOR_NUM_BPB_RPU_COOLANT_INLET_P_KPA, MODBUS_BPB_RPU_COOLANT_INLET_P_KPA_ADDR },
	{ 0, MODBUS_RPU_PWR_W_ADDR },
	{ 0, MODBUS_AALC_TOTAL_PWR_W_ADDR },
	{ 0, MODBUS_RPU_INPUT_VOLT_V_ADDR },
	{ SENSOR_NUM_MB_RPU_AIR_INLET_TEMP_C, MODBUS_MB_RPU_AIR_INLET_TEMP_ADDR },
	{ 0, MODBUS_RPU_PUMP_PWM_TACH_PCT_ADDR },
	{ SENSOR_NUM_PB_1_PUMP_TACH_RPM, MODBUS_PB_1_PUMP_TACH_RPM_ADDR },
	{ SENSOR_NUM_PB_2_PUMP_TACH_RPM, MODBUS_PB_2_PUMP_TACH_RPM_ADDR },
	{ SENSOR_NUM_PB_3_PUMP_TACH_RPM, MODBUS_PB_3_PUMP_TACH_RPM_ADDR },
	{ 0, MODBUS_RPU_FAN1_STATUS_ADDR },
	{ 0, MODBUS_RPU_FAN2_STATUS_ADDR },
	{ SENSOR_NUM_MB_FAN1_TACH_RPM, MODBUS_MB_FAN1_TACH_RPM_ADDR },
	{ SENSOR_NUM_MB_FAN2_TACH_RPM, MODBUS_MB_FAN2_TACH_RPM_ADDR },
	{ 0, MODBUS_AALC_COOLING_CAPACITY_W_ADDR },
	{ 0, MODBUS_RPU_PUMP1_STATUS_ADDR },
	{ 0, MODBUS_RPU_PUMP2_STATUS_ADDR },
	{ 0, MODBUS_RPU_PUMP3_STATUS_ADDR },
	{ 0, MODBUS_RPU_RESERVOIR_STATUS_ADDR },
	{ 0, MODBUS_RPU_LED_RESERVOIR_STATUS_ADDR },
	{ 0, MODBUS_RPU_LED_LEAKAGE_STATUS_ADDR },
	{ 0, MODBUS_RPU_LED_FAULT_STATUS_ADDR },
	{ 0, MODBUS_RPU_LED_POWER_STATUS_ADDR },
	{ SENSOR_NUM_BB_TMP75_TEMP_C, MODBUS_BB_TMP75_TEMP_ADDR },
	{ SENSOR_NUM_BPB_RPU_OUTLET_TEMP_C, MODBUS_BPB_RPU_OUTLET_TEMP_ADDR },
	{ SENSOR_NUM_PDB_HDC1080DMBR_TEMP_C, MODBUS_PDB_HDC1080DMBR_TEMP_ADDR },
	{ SENSOR_NUM_BB_HSC_P48V_TEMP_C, MODBUS_BB_HSC_P48V_TEMP_ADDR },
	{ SENSOR_NUM_BPB_HSC_P48V_TEMP_C, MODBUS_BPB_HSC_P48V_TEMP_ADDR },
	{ SENSOR_NUM_PB_1_HDC1080DMBR_TEMP_C, MODBUS_PB_1_HDC1080DMBR_TEMP_ADDR },
	{ SENSOR_NUM_PB_2_HDC1080DMBR_TEMP_C, MODBUS_PB_2_HDC1080DMBR_TEMP_ADDR },
	{ SENSOR_NUM_PB_3_HDC1080DMBR_TEMP_C, MODBUS_PB_3_HDC1080DMBR_TEMP_ADDR },
	{ SENSOR_NUM_PB_1_HSC_P48V_TEMP_C, MODBUS_PB_1_HSC_P48V_TEMP_ADDR },
	{ SENSOR_NUM_PB_2_HSC_P48V_TEMP_C, MODBUS_PB_2_HSC_P48V_TEMP_ADDR },
	{ SENSOR_NUM_PB_3_HSC_P48V_TEMP_C, MODBUS_PB_3_HSC_P48V_TEMP_ADDR },
	{ SENSOR_NUM_PB_1_HSC_P48V_VIN_VOLT_V, MODBUS_PB_1_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_PB_2_HSC_P48V_VIN_VOLT_V, MODBUS_PB_2_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_PB_3_HSC_P48V_VIN_VOLT_V, MODBUS_PB_3_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_BB_HSC_P51V_VIN_VOLT_V, MODBUS_BB_HSC_P51V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_BPB_HSC_P51V_VIN_VOLT_V, MODBUS_BPB_HSC_P51V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_BB_HSC_P51V_IOUT_CURR_A, MODBUS_BB_HSC_P51V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_BPB_HSC_P51V_IOUT_CURR_A, MODBUS_BPB_HSC_P51V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_PB_1_HSC_P48V_IOUT_CURR_A, MODBUS_PB_1_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_PB_2_HSC_P48V_IOUT_CURR_A, MODBUS_PB_2_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_PB_3_HSC_P48V_IOUT_CURR_A, MODBUS_PB_3_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_BB_HSC_P51V_PIN_PWR_W, MODBUS_BB_HSC_P51V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_BPB_HSC_P51V_PIN_PWR_W, MODBUS_BPB_HSC_P51V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_PB_1_HSC_P48V_PIN_PWR_W, MODBUS_PB_1_HSC_P48V_PIN_PWR_W_ADDR },
	{ 0, MODBUS_PUMP_1_RUNNING_ADDR },
	{ 0, MODBUS_PUMP_2_RUNNING_ADDR },
	{ 0, MODBUS_PUMP_3_RUNNING_ADDR },
	{ SENSOR_NUM_PB_2_HSC_P48V_PIN_PWR_W, MODBUS_PB_2_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_PB_3_HSC_P48V_PIN_PWR_W, MODBUS_PB_3_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_PB_1_FAN_1_TACH_RPM, MODBUS_PB_1_FAN_1_TACH_RPM_ADDR },
	{ SENSOR_NUM_PB_1_FAN_2_TACH_RPM, MODBUS_PB_1_FAN_2_TACH_RPM_ADDR },
	{ SENSOR_NUM_PB_2_FAN_1_TACH_RPM, MODBUS_PB_2_FAN_1_TACH_RPM_ADDR },
	{ SENSOR_NUM_PB_2_FAN_2_TACH_RPM, MODBUS_PB_2_FAN_2_TACH_RPM_ADDR },
	{ SENSOR_NUM_PB_3_FAN_1_TACH_RPM, MODBUS_PB_3_FAN_1_TACH_RPM_ADDR },
	{ SENSOR_NUM_PB_3_FAN_2_TACH_RPM, MODBUS_PB_3_FAN_2_TACH_RPM_ADDR },
	{ SENSOR_NUM_BPB_RACK_PRESSURE_3_P_KPA, MODBUS_BPB_RACK_PRESSURE_3_P_KPA_ADDR },
	{ SENSOR_NUM_BPB_RACK_PRESSURE_4_P_KPA, MODBUS_BPB_RACK_PRESSURE_4_P_KPA_ADDR },
	{ SENSOR_NUM_BPB_RACK_LEVEL_1, MODBUS_BPB_RACK_LEVEL_1_ADDR },
	{ SENSOR_NUM_BPB_RACK_LEVEL_2, MODBUS_BPB_RACK_LEVEL_2_ADDR },
	{ SENSOR_NUM_BPB_CDU_LEVEL_3, MODBUS_BPB_CDU_LEVEL_3_ADDR },
	{ SENSOR_NUM_MB_HUM_PCT_RH, MODBUS_MB_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_PDB_HUM_PCT_RH, MODBUS_PDB_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_PB_1_HUM_PCT_RH, MODBUS_PB_1_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_PB_2_HUM_PCT_RH, MODBUS_PB_2_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_PB_3_HUM_PCT_RH, MODBUS_PB_3_HUM_PCT_RH_ADDR },
	{ 0, MODBUS_HEX_FAN_PWM_TACH_PCT_ADDR },
	{ 0, MODBUS_HEX_PWR_W_ADDR },
	{ 0, MODBUS_HEX_INPUT_VOLT_V_ADDR },
	{ 0, MODBUS_HEX_INPUT_CURRENT_V_ADDR },
	{ SENSOR_NUM_FB_1_FAN_TACH_RPM, MODBUS_FB_1_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_2_FAN_TACH_RPM, MODBUS_FB_2_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_3_FAN_TACH_RPM, MODBUS_FB_3_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_4_FAN_TACH_RPM, MODBUS_FB_4_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_5_FAN_TACH_RPM, MODBUS_FB_5_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_6_FAN_TACH_RPM, MODBUS_FB_6_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_7_FAN_TACH_RPM, MODBUS_FB_7_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_8_FAN_TACH_RPM, MODBUS_FB_8_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_9_FAN_TACH_RPM, MODBUS_FB_9_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_10_FAN_TACH_RPM, MODBUS_FB_10_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_SB_HEX_AIR_OUTLET_1_TEMP_C, MODBUS_SB_HEX_AIR_OUTLET_1_TEMP_ADDR },
	{ SENSOR_NUM_SB_HEX_AIR_OUTLET_2_TEMP_C, MODBUS_SB_HEX_AIR_OUTLET_2_TEMP_ADDR },
	{ SENSOR_NUM_FB_1_HEX_INLET_TEMP_C, MODBUS_FB_1_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_2_HEX_INLET_TEMP_C, MODBUS_FB_2_HEX_INLET_TEMP_ADDR },
	{ 0, MODBUS_HEX_WATER_INLET_TEMP_C_ADDR },
	{ 0, MODBUS_HEX_BLADDER_LEVEL_STATUS_ADDR },
	{ SENSOR_NUM_SB_HEX_AIR_OUTLET_3_TEMP_C, MODBUS_SB_HEX_AIR_OUTLET_3_TEMP_ADDR },
	{ SENSOR_NUM_SB_HEX_AIR_OUTLET_4_TEMP_C, MODBUS_SB_HEX_AIR_OUTLET_4_TEMP_ADDR },
	{ SENSOR_NUM_FB_3_HEX_INLET_TEMP_C, MODBUS_FB_3_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_4_HEX_INLET_TEMP_C, MODBUS_FB_4_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_5_HEX_INLET_TEMP_C, MODBUS_FB_5_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_6_HEX_INLET_TEMP_C, MODBUS_FB_6_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_7_HEX_INLET_TEMP_C, MODBUS_FB_7_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_8_HEX_INLET_TEMP_C, MODBUS_FB_8_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_9_HEX_INLET_TEMP_C, MODBUS_FB_9_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_10_HEX_INLET_TEMP_C, MODBUS_FB_10_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_11_HEX_INLET_TEMP_C, MODBUS_FB_11_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_12_HEX_INLET_TEMP_C, MODBUS_FB_12_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_13_HEX_INLET_TEMP_C, MODBUS_FB_13_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_14_HEX_INLET_TEMP_C, MODBUS_FB_14_HEX_INLET_TEMP_ADDR },
	{ SENSOR_NUM_FB_1_HSC_TEMP_C, MODBUS_FB_1_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_2_HSC_TEMP_C, MODBUS_FB_2_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_3_HSC_TEMP_C, MODBUS_FB_3_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_4_HSC_TEMP_C, MODBUS_FB_4_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_5_HSC_TEMP_C, MODBUS_FB_5_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_6_HSC_TEMP_C, MODBUS_FB_6_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_7_HSC_TEMP_C, MODBUS_FB_7_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_8_HSC_TEMP_C, MODBUS_FB_8_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_9_HSC_TEMP_C, MODBUS_FB_9_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_10_HSC_TEMP_C, MODBUS_FB_10_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_11_HSC_TEMP_C, MODBUS_FB_11_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_12_HSC_TEMP_C, MODBUS_FB_12_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_13_HSC_TEMP_C, MODBUS_FB_13_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_14_HSC_TEMP_C, MODBUS_FB_14_HSC_TEMP_ADDR },
	{ SENSOR_NUM_FB_1_HSC_P48V_VIN_VOLT_V, MODBUS_FB_1_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_2_HSC_P48V_VIN_VOLT_V, MODBUS_FB_2_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_3_HSC_P48V_VIN_VOLT_V, MODBUS_FB_3_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_4_HSC_P48V_VIN_VOLT_V, MODBUS_FB_4_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_5_HSC_P48V_VIN_VOLT_V, MODBUS_FB_5_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_6_HSC_P48V_VIN_VOLT_V, MODBUS_FB_6_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_7_HSC_P48V_VIN_VOLT_V, MODBUS_FB_7_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_8_HSC_P48V_VIN_VOLT_V, MODBUS_FB_8_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_9_HSC_P48V_VIN_VOLT_V, MODBUS_FB_9_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_10_HSC_P48V_VIN_VOLT_V, MODBUS_FB_10_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_11_HSC_P48V_VIN_VOLT_V, MODBUS_FB_11_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_12_HSC_P48V_VIN_VOLT_V, MODBUS_FB_12_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_13_HSC_P48V_VIN_VOLT_V, MODBUS_FB_13_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_14_HSC_P48V_VIN_VOLT_V, MODBUS_FB_14_HSC_P48V_VIN_VOLT_V_ADDR },
	{ SENSOR_NUM_FB_1_HSC_P48V_IOUT_CURR_A, MODBUS_FB_1_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_2_HSC_P48V_IOUT_CURR_A, MODBUS_FB_2_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_3_HSC_P48V_IOUT_CURR_A, MODBUS_FB_3_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_4_HSC_P48V_IOUT_CURR_A, MODBUS_FB_4_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_5_HSC_P48V_IOUT_CURR_A, MODBUS_FB_5_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_6_HSC_P48V_IOUT_CURR_A, MODBUS_FB_6_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_7_HSC_P48V_IOUT_CURR_A, MODBUS_FB_7_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_8_HSC_P48V_IOUT_CURR_A, MODBUS_FB_8_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_9_HSC_P48V_IOUT_CURR_A, MODBUS_FB_9_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_10_HSC_P48V_IOUT_CURR_A, MODBUS_FB_10_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_11_HSC_P48V_IOUT_CURR_A, MODBUS_FB_11_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_12_HSC_P48V_IOUT_CURR_A, MODBUS_FB_12_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_13_HSC_P48V_IOUT_CURR_A, MODBUS_FB_13_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_14_HSC_P48V_IOUT_CURR_A, MODBUS_FB_14_HSC_P48V_IOUT_CURR_A_ADDR },
	{ SENSOR_NUM_FB_1_HSC_P48V_PIN_PWR_W, MODBUS_FB_1_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_2_HSC_P48V_PIN_PWR_W, MODBUS_FB_2_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_3_HSC_P48V_PIN_PWR_W, MODBUS_FB_3_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_4_HSC_P48V_PIN_PWR_W, MODBUS_FB_4_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_5_HSC_P48V_PIN_PWR_W, MODBUS_FB_5_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_6_HSC_P48V_PIN_PWR_W, MODBUS_FB_6_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_7_HSC_P48V_PIN_PWR_W, MODBUS_FB_7_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_8_HSC_P48V_PIN_PWR_W, MODBUS_FB_8_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_9_HSC_P48V_PIN_PWR_W, MODBUS_FB_9_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_10_HSC_P48V_PIN_PWR_W, MODBUS_FB_10_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_11_HSC_P48V_PIN_PWR_W, MODBUS_FB_11_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_12_HSC_P48V_PIN_PWR_W, MODBUS_FB_12_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_13_HSC_P48V_PIN_PWR_W, MODBUS_FB_13_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_14_HSC_P48V_PIN_PWR_W, MODBUS_FB_14_HSC_P48V_PIN_PWR_W_ADDR },
	{ SENSOR_NUM_FB_11_FAN_TACH_RPM, MODBUS_FB_11_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_12_FAN_TACH_RPM, MODBUS_FB_12_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_13_FAN_TACH_RPM, MODBUS_FB_13_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_FB_14_FAN_TACH_RPM, MODBUS_FB_14_FAN_TACH_RPM_ADDR },
	{ SENSOR_NUM_SB_HEX_PRESSURE_1_P_KPA, MODBUS_SB_HEX_PRESSURE_1_P_KPA_ADDR },
	{ SENSOR_NUM_SB_HEX_PRESSURE_2_P_KPA, MODBUS_SB_HEX_PRESSURE_2_P_KPA_ADDR },
	{ SENSOR_NUM_FB_1_HUM_PCT_RH, MODBUS_FB_1_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_2_HUM_PCT_RH, MODBUS_FB_2_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_3_HUM_PCT_RH, MODBUS_FB_3_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_4_HUM_PCT_RH, MODBUS_FB_4_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_5_HUM_PCT_RH, MODBUS_FB_5_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_6_HUM_PCT_RH, MODBUS_FB_6_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_7_HUM_PCT_RH, MODBUS_FB_7_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_8_HUM_PCT_RH, MODBUS_FB_8_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_9_HUM_PCT_RH, MODBUS_FB_9_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_10_HUM_PCT_RH, MODBUS_FB_10_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_11_HUM_PCT_RH, MODBUS_FB_11_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_12_HUM_PCT_RH, MODBUS_FB_12_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_13_HUM_PCT_RH, MODBUS_FB_13_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_FB_14_HUM_PCT_RH, MODBUS_FB_14_HUM_PCT_RH_ADDR },
	{ SENSOR_NUM_BPB_CDU_COOLANT_LEAKAGE_1, MODBUS_LEAK_RPU_INT_ADDR },
	{ SENSOR_NUM_BPB_RACK_COOLANT_LEAKAGE_2, MODBUS_LEAK_RACK_FLOOR_GPO_AND_RELAY_ADDR },
};

static int holding_reg_rd(uint16_t addr, uint16_t *reg, uint16_t reg_qty)
{
	if (cb_num > 0 && (addr > cb_addr[0] && addr <= cb_addr[1])) {
		*reg = regs_rd[cb_num - 1];
		cb_num--;
		return MODBUS_READ_WRITE_REGISTER_SUCCESS;
	}

	cb_num = 0;
	memset(&cb_addr, 0, sizeof(cb_addr));
	memset(&regs_rd, 0, sizeof(regs_rd));

	if (addr < 0x9200) { // sensor addr is less than 0x9200
		int reading = 0;
		if ((reg_qty * 2) != sizeof(reading))
			return MODBUS_NOT_IN_REGISTER_VAL_RANGE;

		for (uint8_t index = 0; index < sensor_config_count; index++) {
			if (plat_modbus_sensors[index].data_addr == addr) {
				uint8_t status =
					get_sensor_reading(sensor_config, sensor_config_count,
							   plat_modbus_sensors[index].sensor_num,
							   &reading, GET_FROM_CACHE);

				if (status ==
				    SENSOR_READ_SUCCESS) { //reading type is int(4Bytes = 2 registers)
					regs_rd[0] = reading & 0x0000FFFF;
					regs_rd[1] = (reading >> 8) >> 8;
					cb_num = reg_qty - 1;
					*reg = regs_rd[cb_num];
					cb_addr[0] = addr;
					cb_addr[1] = addr + cb_num;
					return MODBUS_READ_WRITE_REGISTER_SUCCESS;
				} else {
					LOG_ERR("Read Modbus Sensor failed");
					return MODBUS_READ_WRITE_REGISTER_FAIL;
				}
			}
		}

		LOG_ERR("Wrong Modbus Sensor Addr");
		return MODBUS_ADDR_NOT_DEFINITION;
	} else {
		uint8_t status = 0;
		switch (addr) {
		case FRU_FB_PART_ADDR:
			break;
		case FRU_MFR_MODEL_ADDR:
			break;
		case FRU_MFR_DATE_ADDR:
			break;
		case FRU_MFR_SERIEL_ADDR:
			break;
		case MODBUS_POWER_RPU_ADDR:
			break;
		case FRU_WORKORDER_ADDR:
			break;
		case FRU_HW_REVISION_ADDR:
			break;
		case FRU_FW_REVISION_ADDR:
			break;
		case FRU_TOTAL_UP_TIME_ADDR:
			break;
		case FRU_LAST_ON_TIME_ADDR:
			break;
		case FRU_HMI_REVISION_ADDR:
			break;
		case FRU_NOAH_ARK_CONFIG_ADDR:
			break;
		case FRU_HEATEXCHANGER_CONTROLBOX_FPBN_ADDR:
			break;
		case FRU_QUANTA_FB_PART_ADDR:
			status = modbus_read_fruid_data(regs_rd, addr, reg_qty);
			if (status == FRU_READ_SUCCESS) {
				cb_num = reg_qty - 1;
				*reg = regs_rd[cb_num];
				cb_addr[0] = addr;
				cb_addr[1] = addr + cb_num;
				return MODBUS_READ_WRITE_REGISTER_SUCCESS;
			} else {
				return MODBUS_READ_WRITE_REGISTER_FAIL;
			}
			break;
		default:
			LOG_ERR("Read Modbus Sensor failed");
			return MODBUS_READ_WRITE_REGISTER_FAIL;
			break;
		}

		//printk("Holding register read, addr %u, val %u\n", addr, *reg);

		return MODBUS_READ_WRITE_REGISTER_SUCCESS;
	}

	LOG_ERR("Wrong Modbus Sensor Addr");
	return MODBUS_ADDR_NOT_DEFINITION;
}

static int holding_reg_wr(uint16_t addr, uint16_t reg, uint16_t reg_qty)
{
	uint8_t status = 0;
	if (reg_qty > 0) {
		if (cb_num == 0) {
			cb_num = reg_qty;
			cb_addr[1] = addr + cb_num - 1;
			cb_addr[0] = addr;
		}

		if (cb_num >= 0 && (addr >= cb_addr[0] && addr <= cb_addr[1])) {
			regs_wr[cb_num - 1] = reg;
			cb_num--;
			if (cb_num == 0) {
				goto wr_func;
			} else {
				return MODBUS_READ_WRITE_REGISTER_SUCCESS;
			}
		}
	}

	memset(&cb_addr, 0, sizeof(cb_addr));
	memset(&regs_wr, 0, sizeof(regs_wr));
	cb_num = 0;
	return MODBUS_READ_WRITE_REGISTER_FAIL;

wr_func:
	switch (cb_addr[0]) {
	case FRU_FB_PART_ADDR:
		break;
	case FRU_MFR_MODEL_ADDR:
		break;
	case FRU_MFR_DATE_ADDR:
		break;
	case FRU_MFR_SERIEL_ADDR:
		break;
	case MODBUS_POWER_RPU_ADDR:
		// uint8_t bus, uint8_t addr, bool enable_flag
		status = enable_adm1272_hsc(reg, addr, 1); 
		memset(&cb_addr, 0, sizeof(cb_addr));
		memset(&regs_wr, 0, sizeof(regs_wr));
		cb_num = 0;
		if (status == true)
			return MODBUS_READ_WRITE_REGISTER_SUCCESS;
		else
			return MODBUS_READ_WRITE_REGISTER_FAIL;
		break;
	case FRU_WORKORDER_ADDR:
		break;
	case FRU_HW_REVISION_ADDR:
		break;
	case FRU_FW_REVISION_ADDR:
		break;
	case FRU_TOTAL_UP_TIME_ADDR:
		break;
	case FRU_LAST_ON_TIME_ADDR:
		break;
	case FRU_HMI_REVISION_ADDR:
		break;
	case FRU_NOAH_ARK_CONFIG_ADDR:
		break;
	case FRU_HEATEXCHANGER_CONTROLBOX_FPBN_ADDR:
		break;
	case FRU_QUANTA_FB_PART_ADDR:
		status = modbus_write_fruid_data(regs_wr, cb_addr[0], reg_qty);
		memset(&cb_addr, 0, sizeof(cb_addr));
		memset(&regs_wr, 0, sizeof(regs_wr));
		cb_num = 0;
		if (status == FRU_WRITE_SUCCESS) {
			return MODBUS_READ_WRITE_REGISTER_SUCCESS;
		} else {
			return MODBUS_READ_WRITE_REGISTER_FAIL;
		}
		break;
	default:
		memset(&cb_addr, 0, sizeof(cb_addr));
		memset(&regs_wr, 0, sizeof(regs_wr));
		cb_num = 0;
		LOG_ERR("Read Modbus Sensor failed");
		return MODBUS_ADDR_NOT_DEFINITION;
		break;
	}
	return MODBUS_ADDR_NOT_DEFINITION;
};

static struct modbus_user_callbacks mbs_cbs = {
	.holding_reg_rd = holding_reg_rd,
	.holding_reg_wr = holding_reg_wr,
};

const static struct modbus_iface_param server_param = {
	.mode = MODBUS_MODE_RTU,
	.server = {
		.user_cb = &mbs_cbs,
		.unit_id = MODBUS_UART_NODE_ADDR,
	},
	.serial = {
		.baud = MODBUS_UART_BAUDRATE_LOW,
		.parity = MODBUS_UART_PARITY,
	},
};

static void modbus_server_handler(void *arug0, void *arug1, void *arug2)
{
	int val;

	val = init_modbus_server(*server_iface_name, server_param);
	if (val != 0) {
		LOG_ERR("Failed to initialize server");
		return;
	}
}

//void sensor_poll_init()
void modbus_server_handler_init(void)
{
	k_thread_create(&modbus_server_thread, modbus_server_thread_stack,
			K_THREAD_STACK_SIZEOF(modbus_server_thread_stack), modbus_server_handler,
			NULL, NULL, NULL, CONFIG_MAIN_THREAD_PRIORITY, 0, K_NO_WAIT);
	k_thread_name_set(&modbus_server_thread, "modbus_server_handler");
	return;
}
